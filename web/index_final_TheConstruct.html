<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS Web Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/roslib@1/build/roslib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #414141;
        }

        .dashboard {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .connection-form {
            width: 100%;
            margin-bottom: 20px;
        }

        .joystick-container {
            width: 200px;
            height: 200px;
            background-color: #ddd;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }

        .image-view {
            width: 320px;
            height: 240px;
            background-color: #000;
        }

        .position-display,
        .map-display,
        .readings-display {
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
        }

        .position-display {
            width: 200px;
        }

        .map-display {
            width: 200px;
        }

        .readings-display {
            min-width: 600px;
            background-color: #f0f0f0;
            /* Sensor readings background */
        }

        .readings-container {
            min-height: 200px;
            padding: 5px;
            overflow-y: auto;
        }

        .readings-container ul {
            list-style-type: none;
            padding: 0;
            margin: 5px 0 5px 10px;
            columns: 3;
        }

        .readings-container li {
            font-size: 0.9em;
            padding: 1px 0;
        }

        .sensor-channel {
            margin-bottom: 10px;
            border: 1px solid #00000030;
            padding: 5px;
            border-radius: 3px;
            background-color: #f9f9f9;
        }

        .map-image {
            width: 100%;
            height: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div class="connection-form">
        <input type="text" id="map-name" placeholder="Map Name (e.g., map)">
        <button onclick="connectToROS()">Connect</button>
    </div>
    <div class="dashboard">
        <div class="joystick-container" id="joystick_l"></div>
        <div class="joystick-container" id="joystick_h"></div>

        <img class="image-view" id="camera-feed" alt="Camera Feed">

        <div class="position-display">
            <h3>Position & Orientation</h3>
            <p>X: <span id="position-x">0</span></p>
            <p>Y: <span id="position-y">0</span></p>
            <p>Yaw (&Theta;): <span id="rotation-z">0</span></p>
        </div>

        <div class="map-display">
            <h3>Map</h3>
            <canvas id="map-canvas" class="map-image" width="200" height="200"></canvas>
        </div>

        <div class="readings-display">
            <h3>Sensor Readings (ENS160)</h3>
            <div class="readings-container" id="readings">Awaiting Data...</div>
        </div>
    </div>

    <script>
        let ros;
        let cmdVelTopic;
        let joystick_l, joystick_h;

        // --- Configuration Constants ---
        const MAP_WIDTH_PIXELS = 200;
        const MAP_HEIGHT_PIXELS = 200;
        const MAP_RESOLUTION = 0.05; // meters/pixel
        const ROBOT_RADIUS = 5; // pixels
        const SPEED_VECTOR_SCALE = 50; // pixels per m/s 
        let mapImage = new Image();

        const EXPECTED_KEYS = ['eCO2', 'TVOC', 'AQI', 'R0', 'R1', 'R2', 'R3'];
        const KEYS_PER_CHANNEL = EXPECTED_KEYS.length; // 7
        const MAX_CHANNELS = 6; // CH0 to CH5

        function getRosbridgeAddress() {
            const currentUrl = window.location.href;
            const rosbridgeUrl = currentUrl.replace(/\/webpage\/?$/, '/rosbridge/');
            const rosbridgeAddress = rosbridgeUrl.replace(/^http/, 'ws').replace(/^https/, 'wss');
            return rosbridgeAddress;
        }

        function connectToROS() {
            let mapName = document.getElementById('map-name').value.trim();
            if (!mapName) {
                mapName = "map";
            }

            const rosbridgeAddress = getRosbridgeAddress();
            const mapPath = `maps/${mapName}.png`;

            mapImage.onload = () => {
                console.log('Map image loaded.');
            };
            mapImage.src = mapPath;

            ros = new ROSLIB.Ros({
                url: rosbridgeAddress
            });

            ros.on('connection', function () {
                console.log('Connected to rosbridge:', rosbridgeAddress);
                setupTopics();
            });

            ros.on('error', function (error) {
                console.error('Connection Error:', error);
            });

            ros.on('close', function () {
                console.log('Connection closed.');
            });
        }

        function quaternionToYaw(orientation) {
            const q = orientation;
            // Yaw calculation (rotation around Z-axis)
            const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
            const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
            const yaw = Math.atan2(siny_cosp, cosy_cosp);
            return yaw; // in radians
        }

        function setupTopics() {
            cmdVelTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/cmd_vel',
                messageType: 'geometry_msgs/Twist'
            });

            // --- Camera Feed Subscription ---
            const imageTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/camera1/image_raw/compressed',
                messageType: 'sensor_msgs/CompressedImage'
            });

            imageTopic.subscribe(function (message) {
                document.getElementById('camera-feed').src = "data:image/jpeg;base64," + message.data;
            });

            // --- Odometry Subscription (for Pose and Map Drawing) ---
            const odomTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/odom',
                messageType: 'nav_msgs/Odometry'
            });

            odomTopic.subscribe(function (message) {
                const position = message.pose.pose.position;
                const orientation = message.pose.pose.orientation;
                const twist = message.twist.twist;

                // Update position text displays
                document.getElementById('position-x').textContent = position.x.toFixed(2);
                document.getElementById('position-y').textContent = position.y.toFixed(2);
                const yaw = quaternionToYaw(orientation);
                document.getElementById('rotation-z').textContent = yaw.toFixed(2);

                const velX_robot = twist.linear.x;
                const velY_robot = twist.linear.y;

                // Global velocity (Using rotation matrix)
                const velX_global = velX_robot * Math.cos(yaw) - velY_robot * Math.sin(yaw);
                const velY_global = velX_robot * Math.sin(yaw) + velY_robot * Math.cos(yaw);

                // --- Pass global velocities AND yaw to the drawing function ---
                drawRobotState(position.x, position.y, velX_global, velY_global, yaw);
            });

            // --- Sensor Data Subscription (Custom Message) ---
            const sensorTopic = new ROSLIB.Topic({
                ros: ros,
                name: 'ens160_fused_data',
                messageType: 'ens160_interfaces/msg/SensorData'
            });

            sensorTopic.subscribe(function (message) {
                updateSensorDisplay(message.sensor_readings);
            });

            setupJoysticks();
        }

        function updateSensorDisplay(readings) {
            const container = document.getElementById('readings');
            container.innerHTML = ''; // Clear previous content

            if (readings.length === 0) {
                container.innerHTML = '<p>No sensor data received.</p>';
                return;
            }

            // 1. Calculate how many complete channels were received
            const receivedChannels = Math.floor(readings.length / KEYS_PER_CHANNEL);

            // Optional integrity check
            if (readings.length % KEYS_PER_CHANNEL !== 0 || receivedChannels > MAX_CHANNELS) {
                container.innerHTML = `<p style="color: red;">Error in data structure: ${readings.length} readings received, not a multiple of ${KEYS_PER_CHANNEL} or exceeds ${MAX_CHANNELS} channels.</p>`;
                return;
            }

            let htmlContent = '';

            // 2. Iterate only over the number of received channels
            for (let i = 0; i < receivedChannels; i++) {
                const channelName = `CH${i}`;

                htmlContent += `<div class="sensor-channel">
                                    <strong>${channelName}</strong>:<ul>`;

                // 3. Iterate over the 7 keys per channel
                for (let j = 0; j < KEYS_PER_CHANNEL; j++) {
                    const key = EXPECTED_KEYS[j];
                    const index = i * KEYS_PER_CHANNEL + j; // Calculate the index in the flat array

                    // The ternary operator: check if the value exists, then format, otherwise use "N/A"
                    const value = readings[index] !== undefined ? readings[index].toFixed(2) : "N/A";

                    htmlContent += `<li>${key}: ${value}</li>`;
                }

                htmlContent += `</ul></div>`;
            }

            container.innerHTML = htmlContent;
        }

        function drawRobotState(robotX, robotY, velX, velY, yaw) {
            const canvas = document.getElementById('map-canvas');
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, MAP_WIDTH_PIXELS, MAP_HEIGHT_PIXELS);
            if (mapImage.complete) {
                ctx.drawImage(mapImage, 0, 0, MAP_WIDTH_PIXELS, MAP_HEIGHT_PIXELS);
            }

            // Assuming (0,0) world coordinates map to the center of the image.
            const pixelX = robotX / MAP_RESOLUTION + MAP_WIDTH_PIXELS / 2;
            const pixelY = MAP_HEIGHT_PIXELS / 2 - robotY / MAP_RESOLUTION;
            // The subtraction for Y is common because canvas Y is down, but ROS Y is up.

            // Draw Robot Position
            ctx.beginPath();
            ctx.arc(pixelX, pixelY, ROBOT_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = 'green';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.stroke();

            const orientationLength = ROBOT_RADIUS * 1.5;
            const endYawX = pixelX + Math.cos(yaw) * orientationLength;
            const endYawY = pixelY - Math.sin(yaw) * orientationLength; // Y is inverted

            // Draw the orientation line
            ctx.beginPath();
            ctx.moveTo(pixelX, pixelY);
            ctx.lineTo(endYawX, endYawY);
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'blue';
            ctx.stroke();

            // Calculate Speed and Movement Direction
            const speed = Math.sqrt(velX * velX + velY * velY);
            if (speed > 0.01) {

                const movementAngle = Math.atan2(velY, velX);
                const vectorLength = speed * SPEED_VECTOR_SCALE;

                const endX = pixelX + Math.cos(movementAngle) * vectorLength;
                const endY = pixelY - Math.sin(movementAngle) * vectorLength;

                // Draw Speed/Direction Vector
                ctx.beginPath();
                ctx.moveTo(pixelX, pixelY);
                ctx.lineTo(endX, endY);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'red';
                ctx.stroke();

                // Draw a small arrow head
                ctx.fillStyle = 'red';
                ctx.save();
                ctx.translate(endX, endY);
                ctx.rotate(-movementAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 5);
                ctx.lineTo(-10, -5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        const maxSpeed = 1.0;
        const maxTurn = 1.0;
        const distanceFactor = 75;

        let currentLinearX = 0;
        let currentLinearY = 0;
        let currentAngularZ = 0;

        function publishTwist() {
            const twist = new ROSLIB.Message({
                linear: {
                    x: currentLinearX,
                    y: currentLinearY,
                    z: 0
                },
                angular: {
                    x: 0,
                    y: 0,
                    z: currentAngularZ
                }
            });
            if (cmdVelTopic) {
                cmdVelTopic.publish(twist);
            }
        }

        function setupJoysticks() {
            const options_l = { // Linear X and Angular Z
                zone: document.getElementById('joystick_l'),
                mode: 'static',
                position: {
                    left: '50%',
                    top: '50%'
                },
                color: 'blue',
                size: 150
            };

            const options_h = { // Linear Y (strafe)
                zone: document.getElementById('joystick_h'),
                mode: 'static',
                position: {
                    left: '50%',
                    top: '50%'
                },
                color: 'red',
                size: 150
            };

            joystick_l = nipplejs.create(options_l);
            joystick_h = nipplejs.create(options_h);

            // Left Joystick: Linear X (Forward/Backward) and Angular Z (Turning)
            joystick_l.on('move', function (evt, data) {
                // Linear X (Forward/Backward)
                currentLinearX = Math.sin(data.angle.radian) * maxSpeed * data.distance / distanceFactor;
                // Angular Z (Turning/Yaw)
                currentAngularZ = -Math.cos(data.angle.radian) * maxTurn * data.distance / distanceFactor;
                publishTwist();
            });

            joystick_l.on('end', function () {
                currentLinearX = 0;
                currentAngularZ = 0;
                publishTwist();
            });

            // Right Joystick: Linear Y (Strafe Left/Right)
            joystick_h.on('move', function (evt, data) {
                // Linear Y (Strafe Left/Right)
                currentLinearY = -Math.cos(data.angle.radian) * maxSpeed * data.distance / distanceFactor;
                publishTwist();
            });

            joystick_h.on('end', function () {
                currentLinearY = 0;
                publishTwist();
            });
        }
    </script>
</body>

</html>